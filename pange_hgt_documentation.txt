****************************************************************
Calculating Pangenome and Lateral Rates of Gene Transfer Pipeline
*****************************************************************

I) Find Species Distances' Correlation with Pangenome Size
   -------------------------------------------------------
The initial part of the experiment requires to see if a particular species' pangenome size has
any correlation with the total distance of its subspecies on a phylogenetic tree. This was 
originally to account to see if genetic distance would end up being a confounding variable in 
the final correlation of pangenome and rates of lateral gene transfer.

1) Downloading FNA Files from NCBI - Assembly
Since Roary (the program used to generate pangenomes) only accepts GFF files generated by 
Prokka (has the sequence at the end), FNA files for each bacterial species were downloaded 
from the Assembly site (RefSeq). These files are known to be well annotated, and offer the
complete genome, which caters to our need. 
	
	- type in bacteria name on Assembly database
	- ensure "Complete Genome" is selected on the left sidebar
	- "Download Assemblies" -> Source Database: "RefSeq" -> File Type: "Genomic FASTA" 

2) Eliminating Plasmid Sequences - fnaplasmidtrimmer.py
Some of the downloaded files will have plasmid sequences at the end of the complete genome. Th
is was verified through several codes going through and checking titles, making sure that they
were indeed at the end, and not stuck in a random position. This step can be replicated if
needed for precautionary measures, but after checking multiple bacterial species, this 
appeared to be consistent. Hence, the rest of the sequences after the first one were removed.

	for x in *.fna; do fnaplasmidtrimmer.py $x; done

3) Parsnp - create a tree
Parsnp is a tree generator which focusses on the core genome and throws away the rest, hence
it works decently well for closely related species such as this. However, one must expect to
have a decent amount of genomes before running it through this program. This is why it
would've been important to remove the plasmids. Enter the directory containing the FNA files
and run:

	parsnp -r ! -d .

Note that this chooses a random reference file, but specifying one in particular is completel
optional.

4) Figtree - reroot and save the tree
Parsnp should generate a tree, eliminating only a few of the previously downloaded genomes. 
Transfer the corresponding "parsnp.ggr" file to biolinux and open on Gingr to verify where 
the tree should be rooted. The taxa highlighted in blue will be the new root. Select and 
reroot to that branch on figtree and save it in Newick format.

After the new tree is saved, extract a list of the new tip labels, as these are the files you 
will be working with from now on (NOT the entirety of the originally downloaded files from 
Assembly--these have already been weeded out). You can do this in R with "ape" library:
	
	library("ape")
	tree <- read.tree("species.tree")
	write(tree$tip.labels, "speciesnametiplabels.txt")

Once you have extracted the txt files, you can easily move the files you need into a separate
directory using 
"cp `cat speciesnametiplabels.txt`

5) Running the FNA Files through Prokka
Prokka is a program used to annotate bacterial genomes, and is what is required to generate 
the GFF files which Roary requires. Prokka is only available on biolinux, so all the .fna 
files were copied over via scp. Afterwards, the following shell for loop was used to generate
the GFF files:

	for x in *.fna; do prokka $x --outdir prokka_$x --prefix $x; done

Note that this becomes slightly quicker if you do it on only the parsnp sorted file that you
had weeded out.s

6) Running the GFF Files through Roary
Extract and transfer the newly generated GFF files back to info. Now Roary can be ran on all
these files to generate pangenome data. We chose to do 100 runs of a randomly generated 
subset of 20 for each bacterial species. 

	i)  	ls *.gff > roaryfile.txt
	ii)	mkdir inputroary - to store randomly generated input for each of the 100 runs
	iii)	mkdir outputroary - to store actual Roary output i.e. pangenome info
	iv)	for x in {1..100}; do rdmfilegen.py > inputroary/run$x; done
		
		rdmfilegen.py selects 20 random files from your total gff list, which will
		now become your input
	
	for x in {1..100}; do roary -f outputroary/run$x `cat inputroary`; done

	-f represents the output location where roary spits out the information
	Note: Running 1..100 in one for-loop may be too much, so I actually split up the 
	increments and ran them in parallel (e.g. I ran {1..15} {16..25}...etc. all at the
	same time.

7) Extracting the Pangenome Size
Once Roary has finished running, use the following command within the "outputroary" directory 
to find the pangenome size, corresponding to run number:

	for x in {1..100}; do cat run$x/*.txt | grep "Total genes" >> species_pange.txt

You'll want to go into vim and remove the "Total genes...etc.", as the numeric column is
the only thing we want.

8) Retrieving Genetic Distance - tree_distance.R
This code calculates the total distances of each individual tree containing the twenty taxa
by preening away the unneeded branches and then calculating the sum of the remaining branches.
Again, we want to correspond this to run number so we run the following for-loop:
	

	First argument = phylogenetic tree formerly generated by parsnp
	Second argument = the roaryinput run list

	for x in {1..100}; do Rscript tree_distance.R species.tree roaryinput/run$x >> 
	species_distance.txt; done

	Note: Your directories are probably guaranteed to be different from mine so pay 
	attention to paths and use absolute ones if necessary. 
  
Once this information has been retrieved, it is easy to concatenate the files together and
plot them as necessary.

II) "Rarefaction Curves"

To be written. I don't remember the exact steps I used, but it's a similar idea to the 
former, and rdmfilegen.py was able to receive arguments instead of just spitting out 
20 random files.

III) Gene Family - Presence/Absence Matrix

1) Downloading the GBFF Files from NCBI - Assembly
This time, we need the genbank files in order to extract accession numbers and protein IDs 
from each.

By using the same method, download everything available, and extract the ones you need that 
had been selected by parsnp.
There are multiple ways to do this, but I personally just modified the extensions on the 
roaryfile.txt (tiplabels.txt should work too) and used the approachable cp `cat roaryfile.txt`
once again.

**DON'T FORGET TO REMOVE PLASMID INFO** 
Even the GenBank files from assembly will contain plasmid
info so remove them using gbktrimmer.py (works in a similar format to fnaplasmidtrimmer.py
and assumes plasmids are listed /after/ the actual genome sequence).

2) Extract Protein Sequences - modified_get_features.pl
This extracts the protein sequences from the genbank files

	mkdir getfeatures
	for x in *.gbff; do modified_get_features.pl $x > getfeatures/`basename $x .gbff`.faa
	2>> errorfile.txt; done

The errorfile.txt is technically not necessary, but can be a good reference later all for 
possible pseudogenes.

3) Make a blast database
First, concatenate all the .faas into one file.
	
	cat *.faa > {# of files}{bacteria_name}.faa

Using vim, remove all spaces and commas from the sequence IDs so that BLAST will be able to 
recognize the format. NOTE: you might want to keep the original file with the spaces in it, 
as it may help with some regex in the latter parts, though I have written mine without the 
need for it.
Afterwards, the blast database can be made using:

	makeblastdb -in {#}{bacteria_name}.faa -out parsed{#}{bacteria_name}.db -dbtype 
	prot -parse_seqids -max_file_sz '200'

4) Run the reciprocal blastp 

	blastp -db [# OF DATABASE i.e. parsed{#}{bacteria_name} without .db extension] -query 
	[concatenated faa file] -out allvsall_wotransposase_softmask_sw -evalue 5e-2 -outfmt 
	'7 seqid qlen qstart qend length sseqid slen qcovs score bitscore evalue' 
	-soft_masking true -use_sw_tback &

	Note: The num_threads argument was purposely left out due to segmentation faults and
 abrupt abortions on info113, info114 and info115. As a result, this was omitted entirely. 
Alternative methods could be attempting to use a lesser number of cores or splitting up the
 large .faa file and manually running them in parallel.

5) Weeding Out blastp results - extract85.R

We only want the decents, hence all hits which match length less than 85% of the query length
 or are hits to the same gene are removed from the blastp file. extract85.R does this by 
importing the file as a table and checks the relevant columns.

By running,
	
	extract85.R allvsall_wotransposase_softmask_sw 

The files outputwolessthan85.txt and outputwohitstosamegene.txt are produced. Technically, the
former file seems to only exist as a transition file, and can probably be automatically in 
future reversions of the code/pipeline.

6) Editing input for "genefamily11.R"
genefamily11.R requires the input file to be labelled "output.txt", and is an adjusted version 
of "outputwohitstothesamegene.txt". 
The format requires for the long winded sequence IDs to be removed and replaced with only the 
relevant accession number and protein ID for columns 1 and 7(?). 

I personally used vim regex to complete the task although you can do it any which way you wish
. Making sure the pattern correlates, use the vim regex:

	:%s/[A-Z]\{2}\d\{6}\zs.\{-}\ze[A-Z]\{3}\d\{5}\.\d/\t/g

NOTE: Your patterns may vary, so make sure to check and verify.

7) Forming Gene Families - genefamily11.R
	
	R --vanilla <genefamily11.R> genefamily11.out 	

This is where the gene families are finally formed and generated. The code runs and determines
gene family by identifying genes which have reciprocal blast hits on each other. Note that
if gene A hits gene B, and gene B hits gene C, then A, B and C are a family.

Genes which have no hits are printed into genesforNR.txt and the image containing the lists 
of lists of genes (i.e. the gene families) are saved into the session image "gfcode1.Rdata"

8) Verifying Singleton Genes
In order to verify that the single genes (i.e. gene families of one) are actually significant 
and a "valid" gene, the list of proteins from  geneforNR.txt are rerun through blastp against
the NR database.

	-Using vim, yank solely the protein IDs out from the generated list (this should be
	 easily done using CTRL+V, or regex if you are comfortable with that). Write that to
	 separate text file.
	-Run matchingprotid.py. This function receives two arguments: the first being the 
	concatenated file generated from modified_get_features.pl (spaces shouldn't matter
	but personally I did mine without spaces), and the second argument is the text file
	that was just generated

	matchingprotid.py seeks to pull out sequence ONLY if it contains the relevant protein
	ID

Transfer the new list of sequences to the scratch disk and run a blastp on it against 
the nr databases:

	blastp -db /1/scratch/blastdb/nr -query proteinseqlist.txt -out [OUTPUT NAME] -evalue
	0.05 -parse_deflines -outfmt '7 seqid qlen qstart qend length sseqid slen qcovs score
	bitscore evalue stitle sallseqid salltitles' -soft_masking true -use_sw_tback &


8) Generating Presence Absence Matrix
In order to run indelrates from indelmiss in order to calculate the lateral rates of gene
transfer, input requires a presence absence matrix and a phylogenetic tree (pre-generated
from parsnp from earlier).

The original way of doing this was through Utkarsh and Athena's genefamily11.R code to 
generate the gene families, but that method proved to be too time consuming. However,
this can still be used if there is a smaller sample size.

Dr. Golding rewrote a perl code that would generate gene families in a more efficient
amount of time. This data is then inputted into Sid's "createPresenceAbsencemtrix.R" code
with input as followed:

	-The txt output generated from Brian's "genefamily11.pl"
	-A directory containing files with the genome accession numbers as the file name 
	and all their respective protein ids listed within. This can be done using Sid's
	code "getTaxaNamesAndProts.bash", with the input argument being the .faa file 
	generated by Brian's "get_featuredmodified.pl" 

Once this code is properly executed, you should obtain a matrix with all the accession
numbers signifying the rows and a "0" or "1" denoting whether or not a gene from that 
organism is present in a particular family number.

Save the .Rdata as well as the output matrix separately as a csv, as this will be your 
input into "indelmiss".

9) Running "indelrates" from indelmiss
indelmisstestscript.R provides the steps I personally used to generate an original test
from a sample of five salmonella bacteria. 

The data outputs in four different models (M1, M2, M3, M4) that can be used and recorded 
as necessary.


